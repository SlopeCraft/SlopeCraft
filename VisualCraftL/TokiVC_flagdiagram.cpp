/*
 Copyright Â© 2021-2026  TokiNoBug
This file is part of SlopeCraft.

    SlopeCraft is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    SlopeCraft is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with SlopeCraft. If not, see <https://www.gnu.org/licenses/>.

    Contact with me:
    github:https://github.com/SlopeCraft/SlopeCraft
    bilibili:https://space.bilibili.com/351429231
*/

#include "TokiVC.h"
#include "VCL_internal.h"
#include "VisualCraftL.h"

#ifdef min
#undef min
#endif

constexpr uint32_t reverse_color(uint32_t ARGB_src) noexcept {
  return ARGB32(255 - getR(ARGB_src), 255 - getG(ARGB_src),
                255 - getB(ARGB_src), getA(ARGB_src));
}

void reverse_color(uint32_t *ptr, size_t num_pixels) noexcept {
  // this can be vertorized by compiler optimization
  for (uint32_t *p = ptr; p < ptr + num_pixels; p++) {
    *p = reverse_color(*p);
  }
}

constexpr uint32_t reverse_byte(uint32_t v) noexcept {
  const uint32_t a = (v & 0xFF'00'00'00) >> 24;
  const uint32_t b = (v & 0x00'FF'00'00) >> 8;
  const uint32_t c = (v & 0x00'00'FF'00) << 8;
  const uint32_t d = (v & 0x00'00'00'FF) << 24;

  return a | b | c | d;
}

void ARGB_to_AGBR(uint32_t *ptr, size_t num_pixels) noexcept {
  for (uint32_t *p = ptr; p < ptr + num_pixels; p++) {
    const uint32_t A = getA(*p);
    *p = (*p) << 8 | A;
    *p = reverse_byte(*p);
  }
}

#include <FlatDiagram/FlatDiagram.h>

bool TokiVC::export_flag_diagram(const char *png_filename,
                                 const flag_diagram_option &opt,
                                 int layer_idx) const noexcept {
  if (this->_step < ::VCL_Kernel_step::VCL_wait_for_build) {
    VCL_report(VCL_report_type_t::error,
               "Trying to export flag diagram without image converted.");
    return false;
  }

  std::shared_lock<std::shared_mutex> lkgd(TokiVC_internal::global_lock);
  std::array<std::pair<std::string, std::string>, 4> txt{
      std::make_pair<std::string, std::string>(
          "Title", "Flat diagram generated by VisualCraftL."),
      std::make_pair<std::string, std::string>("Software", "VisualCraftL"),
      std::make_pair<std::string, std::string>(
          "Description",
          "This image is a flat diagram created by VisualCraftL which is is a "
          "subproject of SlopeCraft, developed by TokiNoBug."),
      std::make_pair<std::string, std::string>(
          "Comment",
          "SlopeCraft is a free software published "
          "under GPLv3 license. You can find "
          "its repository at https://github.com/SlopeCraft/SlopeCraft")};

  this->img_cvter.ui.rangeSet(0, this->img_cvter.rows(), 0);
  const libFlatDiagram::fd_option fdopt{
      .row_start = opt.row_start,
      .row_end = opt.row_end,
      .cols = this->cols(),
      .split_line_row_margin = opt.split_line_row_margin,
      .split_line_col_margin = opt.split_line_col_margin,
      .png_compress_level = opt.png_compress_level,
      .png_compress_memory_level = opt.png_compress_memory_level,
  };
  Eigen::Array<uint32_t, 16, 16, Eigen::RowMajor> empty_image;
  empty_image.fill(0x00'FF'FF'FF);
  auto get_block_image = [&](int64_t r,
                             int64_t c) -> libFlatDiagram::block_img_ref_t {
    const uint16_t current_color_idx = this->img_cvter.color_id(r, c);

    const auto &variant =
        TokiVC::LUT_basic_color_idx_to_blocks[current_color_idx];
    const VCL_block *blkp = nullptr;
    if (variant.index() == 0) {
      if (layer_idx == 0) {
        blkp = std::get<0>(variant);
      }
    } else {
      const auto &vec = std::get<1>(variant);

      if (layer_idx < (int)vec.size()) {
        blkp = vec[layer_idx];
      }
    }
    if (c == 0)
      this->img_cvter.ui.rangeSet(0, this->img_cvter.rows(), r - opt.row_start);

    if (blkp == nullptr) {
      return libFlatDiagram::block_img_ref_t{empty_image.data()};
    }
    return libFlatDiagram::block_img_ref_t{
        blkp->project_image_on_exposed_face.data()};
  };
  const auto err_string = libFlatDiagram::export_flat_diagram(
      png_filename, fdopt, get_block_image, txt);

  this->img_cvter.ui.rangeSet(0, this->img_cvter.rows(),
                              this->img_cvter.rows());
  return true;
}
